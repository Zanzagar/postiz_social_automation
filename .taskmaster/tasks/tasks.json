{
  "data": {
    "master": {
      "tasks": [],
      "metadata": {
        "projectName": "Postiz Social Media Automation",
        "createdAt": "2026-02-20",
        "version": "1.0.0"
      }
    }
  },
  "health-monitoring": {
    "tasks": [
      {
        "id": "1",
        "title": "Create Python project structure and dependencies",
        "description": "Initialize Python project with pyproject.toml, create scripts/ and var/ directories, and define dependencies (docker, httpx, sqlite3 stdlib).",
        "details": "1. Create `pyproject.toml` with:\n   - name: postiz-health-monitor\n   - python >= 3.11\n   - dependencies: docker>=7.0.0, httpx>=0.27.0\n   - optional dev dependencies: pytest, pytest-asyncio\n\n2. Create directory structure:\n   ```\n   scripts/\n   var/.gitkeep\n   ```\n\n3. Add to .gitignore:\n   ```\n   var/*.sqlite\n   __pycache__/\n   *.pyc\n   .venv/\n   ```\n\n4. Update .env.example with health monitoring config:\n   ```\n   # Health Monitoring (optional)\n   HEALTH_CHECK_INTERVAL=60\n   HEALTH_WEBHOOK_URL=\n   HEALTH_DB_PATH=var/health.sqlite\n   ```",
        "testStrategy": "Verify pyproject.toml is valid with `pip install -e .` or `uv pip install -e .`. Confirm directories exist and .gitignore patterns work.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed - straightforward file creation task",
        "updatedAt": "2026-02-21T01:08:48.449Z"
      },
      {
        "id": "2",
        "title": "Implement SQLite database schema and storage layer",
        "description": "Create the health check database schema with health_checks and state_transitions tables, plus a storage class for CRUD operations.",
        "details": "Create `scripts/health_storage.py`:\n\n```python\nimport sqlite3\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import Optional\nimport json\nimport os\n\nDEFAULT_DB_PATH = Path(os.getenv('HEALTH_DB_PATH', 'var/health.sqlite'))\n\nclass HealthStorage:\n    def __init__(self, db_path: Path = DEFAULT_DB_PATH):\n        self.db_path = db_path\n        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n        self._init_schema()\n    \n    def _init_schema(self):\n        with sqlite3.connect(self.db_path) as conn:\n            conn.executescript('''\n                CREATE TABLE IF NOT EXISTS health_checks (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    service_name TEXT NOT NULL,\n                    status TEXT NOT NULL,\n                    response_time_ms INTEGER,\n                    details TEXT,\n                    checked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                );\n                CREATE INDEX IF NOT EXISTS idx_health_service_time \n                    ON health_checks(service_name, checked_at);\n                \n                CREATE TABLE IF NOT EXISTS state_transitions (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    service_name TEXT NOT NULL,\n                    from_status TEXT NOT NULL,\n                    to_status TEXT NOT NULL,\n                    webhook_sent BOOLEAN DEFAULT FALSE,\n                    transitioned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                );\n                CREATE INDEX IF NOT EXISTS idx_transitions_service \n                    ON state_transitions(service_name, transitioned_at);\n            ''')\n    \n    def record_check(self, service_name: str, status: str, \n                     response_time_ms: Optional[int] = None,\n                     details: Optional[dict] = None) -> int:\n        \"\"\"Record a health check result. Returns the row ID.\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            cursor = conn.execute(\n                '''INSERT INTO health_checks \n                   (service_name, status, response_time_ms, details)\n                   VALUES (?, ?, ?, ?)''',\n                (service_name, status, response_time_ms, \n                 json.dumps(details) if details else None)\n            )\n            return cursor.lastrowid\n    \n    def get_last_status(self, service_name: str) -> Optional[str]:\n        \"\"\"Get the most recent status for a service.\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            row = conn.execute(\n                '''SELECT status FROM health_checks \n                   WHERE service_name = ? \n                   ORDER BY checked_at DESC LIMIT 1''',\n                (service_name,)\n            ).fetchone()\n            return row[0] if row else None\n    \n    def record_transition(self, service_name: str, \n                          from_status: str, to_status: str) -> int:\n        \"\"\"Record a state transition. Returns the row ID.\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            cursor = conn.execute(\n                '''INSERT INTO state_transitions \n                   (service_name, from_status, to_status)\n                   VALUES (?, ?, ?)''',\n                (service_name, from_status, to_status)\n            )\n            return cursor.lastrowid\n    \n    def mark_webhook_sent(self, transition_id: int):\n        \"\"\"Mark a transition's webhook as sent.\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            conn.execute(\n                'UPDATE state_transitions SET webhook_sent = TRUE WHERE id = ?',\n                (transition_id,)\n            )\n    \n    def get_history(self, hours: int = 24, \n                    service_name: Optional[str] = None) -> list[dict]:\n        \"\"\"Get health check history for the last N hours.\"\"\"\n        query = '''SELECT service_name, status, response_time_ms, \n                          details, checked_at\n                   FROM health_checks \n                   WHERE checked_at >= datetime('now', ?)'''\n        params = [f'-{hours} hours']\n        if service_name:\n            query += ' AND service_name = ?'\n            params.append(service_name)\n        query += ' ORDER BY checked_at DESC'\n        \n        with sqlite3.connect(self.db_path) as conn:\n            conn.row_factory = sqlite3.Row\n            return [dict(row) for row in conn.execute(query, params)]\n    \n    def get_uptime_stats(self, days: int = 7) -> dict[str, float]:\n        \"\"\"Calculate uptime percentage per service over N days.\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            rows = conn.execute('''\n                SELECT service_name,\n                       SUM(CASE WHEN status = 'healthy' THEN 1 ELSE 0 END) as healthy,\n                       COUNT(*) as total\n                FROM health_checks\n                WHERE checked_at >= datetime('now', ?)\n                GROUP BY service_name\n            ''', (f'-{days} days',)).fetchall()\n            return {row[0]: (row[1] / row[2] * 100) if row[2] > 0 else 0.0 \n                    for row in rows}\n```",
        "testStrategy": "Unit tests with in-memory SQLite (`:memory:`):\n1. Test schema creation is idempotent\n2. Test record_check and retrieval\n3. Test get_last_status returns None for unknown service\n4. Test state transitions recording\n5. Test history filtering by hours and service\n6. Test uptime calculation with known data",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed - implementation is fully specified in task details",
        "updatedAt": "2026-02-21T01:10:25.162Z"
      },
      {
        "id": "3",
        "title": "Implement Docker service health checker",
        "description": "Create a health checker that uses the Docker SDK to check container health status for all 7 services, with appropriate check methods per service type.",
        "details": "Create `scripts/health_checker.py`:\n\n```python\nimport docker\nimport httpx\nimport time\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom enum import Enum\n\nclass HealthStatus(Enum):\n    HEALTHY = 'healthy'\n    UNHEALTHY = 'unhealthy'\n    MISSING = 'missing'\n\n@dataclass\nclass HealthResult:\n    service_name: str\n    status: HealthStatus\n    response_time_ms: int\n    details: Optional[dict] = None\n\n# Map container names to their service identifiers\nSERVICE_CONTAINERS = {\n    'postiz': 'postiz',\n    'postiz-postgres': 'postiz-postgres',\n    'postiz-redis': 'postiz-redis',\n    'temporal': 'postiz-temporal',\n    'temporal-postgresql': 'postiz-temporal-postgres',\n    'temporal-elasticsearch': 'postiz-temporal-es',\n    'temporal-ui': 'postiz-temporal-ui',\n}\n\nclass HealthChecker:\n    def __init__(self):\n        try:\n            self.client = docker.from_env()\n            self.client.ping()  # Verify connection\n        except docker.errors.DockerException as e:\n            raise RuntimeError(f'Cannot connect to Docker daemon: {e}')\n    \n    def check_all_services(self) -> list[HealthResult]:\n        \"\"\"Check health of all services in the stack.\"\"\"\n        results = []\n        for service_name, container_name in SERVICE_CONTAINERS.items():\n            result = self.check_service(service_name, container_name)\n            results.append(result)\n        return results\n    \n    def check_service(self, service_name: str, \n                      container_name: str) -> HealthResult:\n        \"\"\"Check health of a specific service.\"\"\"\n        start = time.perf_counter()\n        \n        try:\n            container = self.client.containers.get(container_name)\n        except docker.errors.NotFound:\n            elapsed_ms = int((time.perf_counter() - start) * 1000)\n            return HealthResult(\n                service_name=service_name,\n                status=HealthStatus.MISSING,\n                response_time_ms=elapsed_ms,\n                details={'error': f'Container {container_name} not found'}\n            )\n        except docker.errors.APIError as e:\n            elapsed_ms = int((time.perf_counter() - start) * 1000)\n            return HealthResult(\n                service_name=service_name,\n                status=HealthStatus.UNHEALTHY,\n                response_time_ms=elapsed_ms,\n                details={'error': f'Docker API error: {e}'}\n            )\n        \n        # Check container state\n        if container.status != 'running':\n            elapsed_ms = int((time.perf_counter() - start) * 1000)\n            return HealthResult(\n                service_name=service_name,\n                status=HealthStatus.UNHEALTHY,\n                response_time_ms=elapsed_ms,\n                details={'error': f'Container not running: {container.status}'}\n            )\n        \n        # Use Docker's built-in healthcheck status if available\n        health = container.attrs.get('State', {}).get('Health', {})\n        health_status = health.get('Status')\n        \n        if health_status == 'healthy':\n            elapsed_ms = int((time.perf_counter() - start) * 1000)\n            return HealthResult(\n                service_name=service_name,\n                status=HealthStatus.HEALTHY,\n                response_time_ms=elapsed_ms,\n                details={'docker_health': health_status}\n            )\n        elif health_status in ('unhealthy', 'starting'):\n            elapsed_ms = int((time.perf_counter() - start) * 1000)\n            # Get last health check log if available\n            log = health.get('Log', [{}])[-1] if health.get('Log') else {}\n            return HealthResult(\n                service_name=service_name,\n                status=HealthStatus.UNHEALTHY if health_status == 'unhealthy' \n                       else HealthStatus.HEALTHY,  # 'starting' = not yet failed\n                response_time_ms=elapsed_ms,\n                details={\n                    'docker_health': health_status,\n                    'last_output': log.get('Output', '')[:500]\n                }\n            )\n        \n        # No healthcheck defined - container is running, assume healthy\n        elapsed_ms = int((time.perf_counter() - start) * 1000)\n        return HealthResult(\n            service_name=service_name,\n            status=HealthStatus.HEALTHY,\n            response_time_ms=elapsed_ms,\n            details={'docker_health': 'none', 'container_status': 'running'}\n        )\n    \n    def check_http_endpoint(self, url: str, timeout: float = 5.0) -> tuple[bool, dict]:\n        \"\"\"Helper to check an HTTP endpoint. Returns (healthy, details).\"\"\"\n        try:\n            with httpx.Client(timeout=timeout) as client:\n                resp = client.get(url)\n                if resp.status_code < 400:\n                    return True, {'status_code': resp.status_code}\n                return False, {'status_code': resp.status_code, \n                               'body': resp.text[:200]}\n        except httpx.RequestError as e:\n            return False, {'error': str(e)}\n```",
        "testStrategy": "1. Unit tests with mocked docker.Client:\n   - Test container not found returns MISSING\n   - Test container not running returns UNHEALTHY\n   - Test healthy container returns HEALTHY\n   - Test healthcheck status parsing\n2. Integration test (requires Docker running):\n   - Start a test container, verify check works\n   - Use pytest markers to skip if Docker unavailable",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed - implementation is fully specified in task details"
      },
      {
        "id": "4",
        "title": "Implement state transition detection and webhook notification",
        "description": "Create logic to detect when a service transitions between healthy/unhealthy states and send webhook notifications to n8n.",
        "details": "Create `scripts/health_notifier.py`:\n\n```python\nimport httpx\nimport os\nimport time\nfrom datetime import datetime, timezone\nfrom typing import Optional\nfrom health_storage import HealthStorage\nfrom health_checker import HealthResult, HealthStatus\n\nWEBHOOK_URL = os.getenv('HEALTH_WEBHOOK_URL', '')\nSTACK_NAME = 'postiz-social-automation'\nMAX_RETRIES = 3\nRETRY_BACKOFF = [1, 2, 4]  # seconds\n\nclass HealthNotifier:\n    def __init__(self, storage: HealthStorage, webhook_url: str = WEBHOOK_URL):\n        self.storage = storage\n        self.webhook_url = webhook_url\n    \n    def process_result(self, result: HealthResult) -> Optional[int]:\n        \"\"\"Process a health check result. Returns transition ID if state changed.\"\"\"\n        current_status = result.status.value\n        previous_status = self.storage.get_last_status(result.service_name)\n        \n        # Record the check\n        self.storage.record_check(\n            service_name=result.service_name,\n            status=current_status,\n            response_time_ms=result.response_time_ms,\n            details=result.details\n        )\n        \n        # Detect transition (ignore if first check or same status)\n        if previous_status is None or previous_status == current_status:\n            return None\n        \n        # Record transition\n        transition_id = self.storage.record_transition(\n            service_name=result.service_name,\n            from_status=previous_status,\n            to_status=current_status\n        )\n        \n        # Send webhook if configured\n        if self.webhook_url:\n            success = self.send_webhook(\n                service_name=result.service_name,\n                from_status=previous_status,\n                to_status=current_status,\n                details=result.details\n            )\n            if success:\n                self.storage.mark_webhook_sent(transition_id)\n        \n        return transition_id\n    \n    def send_webhook(self, service_name: str, from_status: str, \n                     to_status: str, details: Optional[dict]) -> bool:\n        \"\"\"Send webhook notification with retry logic.\"\"\"\n        payload = {\n            'event': 'service_status_change',\n            'service': service_name,\n            'from_status': from_status,\n            'to_status': to_status,\n            'details': details.get('error', '') if details else '',\n            'timestamp': datetime.now(timezone.utc).isoformat(),\n            'stack': STACK_NAME\n        }\n        \n        for attempt, backoff in enumerate(RETRY_BACKOFF):\n            try:\n                with httpx.Client(timeout=10.0) as client:\n                    resp = client.post(self.webhook_url, json=payload)\n                    if resp.status_code < 400:\n                        return True\n                    # Non-retryable error\n                    if resp.status_code in (400, 401, 403, 404):\n                        print(f'Webhook failed (non-retryable): {resp.status_code}')\n                        return False\n            except httpx.RequestError as e:\n                print(f'Webhook attempt {attempt + 1} failed: {e}')\n            \n            if attempt < len(RETRY_BACKOFF) - 1:\n                time.sleep(backoff)\n        \n        return False\n\n\ndef run_checks_with_notifications(checker, notifier) -> list[dict]:\n    \"\"\"Run all health checks and process results through notifier.\"\"\"\n    results = checker.check_all_services()\n    transitions = []\n    \n    for result in results:\n        transition_id = notifier.process_result(result)\n        if transition_id:\n            transitions.append({\n                'service': result.service_name,\n                'to': result.status.value,\n                'transition_id': transition_id\n            })\n    \n    return transitions\n```",
        "testStrategy": "1. Unit tests:\n   - Test no transition on first check\n   - Test no transition when status unchanged\n   - Test transition detected when status changes\n   - Test webhook payload structure\n   - Mock httpx to test retry logic\n   - Test backoff timing (with mocked sleep)\n2. Integration test with mock webhook server:\n   - Start a local HTTP server\n   - Verify webhook delivery",
        "priority": "high",
        "dependencies": [
          "2",
          "3"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed - implementation is fully specified in task details"
      },
      {
        "id": "5",
        "title": "Create main health monitor script",
        "description": "Implement the main monitoring script that orchestrates health checks, can run once or continuously, and handles Docker daemon errors gracefully.",
        "details": "Create `scripts/health_monitor.py`:\n\n```python\n#!/usr/bin/env python3\n\"\"\"Health monitor for Postiz Docker Compose stack.\"\"\"\n\nimport argparse\nimport os\nimport sys\nimport time\nfrom pathlib import Path\n\n# Ensure scripts directory is in path for local imports\nscripts_dir = Path(__file__).parent\nif str(scripts_dir) not in sys.path:\n    sys.path.insert(0, str(scripts_dir))\n\nfrom health_checker import HealthChecker, HealthStatus\nfrom health_storage import HealthStorage\nfrom health_notifier import HealthNotifier, run_checks_with_notifications\n\nDEFAULT_INTERVAL = int(os.getenv('HEALTH_CHECK_INTERVAL', '60'))\n\n\ndef run_once(verbose: bool = False) -> int:\n    \"\"\"Run health checks once. Returns 0 if all healthy, 1 otherwise.\"\"\"\n    try:\n        checker = HealthChecker()\n    except RuntimeError as e:\n        print(f'ERROR: {e}', file=sys.stderr)\n        print('Is Docker running?', file=sys.stderr)\n        return 2\n    \n    storage = HealthStorage()\n    notifier = HealthNotifier(storage)\n    \n    results = checker.check_all_services()\n    transitions = []\n    all_healthy = True\n    \n    for result in results:\n        if verbose:\n            status_icon = '✓' if result.status == HealthStatus.HEALTHY else '✗'\n            print(f'{status_icon} {result.service_name}: {result.status.value} '\n                  f'({result.response_time_ms}ms)')\n        \n        if result.status != HealthStatus.HEALTHY:\n            all_healthy = False\n        \n        transition_id = notifier.process_result(result)\n        if transition_id:\n            transitions.append({\n                'service': result.service_name,\n                'status': result.status.value,\n                'transition_id': transition_id\n            })\n    \n    if verbose and transitions:\n        print(f'\\nState transitions detected: {len(transitions)}')\n        for t in transitions:\n            print(f'  - {t[\"service\"]} -> {t[\"status\"]}')\n    \n    return 0 if all_healthy else 1\n\n\ndef run_continuous(interval: int = DEFAULT_INTERVAL, verbose: bool = False):\n    \"\"\"Run health checks continuously at specified interval.\"\"\"\n    print(f'Starting continuous health monitoring (interval: {interval}s)')\n    print('Press Ctrl+C to stop\\n')\n    \n    try:\n        checker = HealthChecker()\n    except RuntimeError as e:\n        print(f'ERROR: {e}', file=sys.stderr)\n        return 2\n    \n    storage = HealthStorage()\n    notifier = HealthNotifier(storage)\n    \n    try:\n        while True:\n            timestamp = time.strftime('%Y-%m-%d %H:%M:%S')\n            if verbose:\n                print(f'[{timestamp}] Running health checks...')\n            \n            transitions = run_checks_with_notifications(checker, notifier)\n            \n            if transitions:\n                for t in transitions:\n                    print(f'[{timestamp}] TRANSITION: {t[\"service\"]} -> {t[\"to\"]}')\n            elif verbose:\n                print(f'[{timestamp}] All services stable')\n            \n            time.sleep(interval)\n    except KeyboardInterrupt:\n        print('\\nStopping health monitor')\n        return 0\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Health monitor for Postiz Docker Compose stack'\n    )\n    parser.add_argument(\n        '--once', action='store_true',\n        help='Run checks once and exit (default: continuous)'\n    )\n    parser.add_argument(\n        '--interval', type=int, default=DEFAULT_INTERVAL,\n        help=f'Seconds between checks (default: {DEFAULT_INTERVAL})'\n    )\n    parser.add_argument(\n        '-v', '--verbose', action='store_true',\n        help='Show detailed output'\n    )\n    \n    args = parser.parse_args()\n    \n    if args.once:\n        sys.exit(run_once(verbose=args.verbose))\n    else:\n        sys.exit(run_continuous(interval=args.interval, verbose=args.verbose))\n\n\nif __name__ == '__main__':\n    main()\n```",
        "testStrategy": "1. Unit tests:\n   - Test run_once with mocked checker (all healthy)\n   - Test run_once with mocked checker (some unhealthy)\n   - Test Docker daemon error handling\n2. Integration test:\n   - Run actual script with --once flag\n   - Verify exit codes match service state",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed - implementation is fully specified in task details"
      },
      {
        "id": "6",
        "title": "Implement CLI for status, history, and uptime queries",
        "description": "Create a CLI interface for querying current status, recent health history, and uptime percentages.",
        "details": "Create `scripts/health_cli.py`:\n\n```python\n#!/usr/bin/env python3\n\"\"\"CLI for querying Postiz stack health status and history.\"\"\"\n\nimport argparse\nimport sys\nfrom pathlib import Path\nfrom datetime import datetime\n\nscripts_dir = Path(__file__).parent\nif str(scripts_dir) not in sys.path:\n    sys.path.insert(0, str(scripts_dir))\n\nfrom health_checker import HealthChecker, HealthStatus, SERVICE_CONTAINERS\nfrom health_storage import HealthStorage\n\n\ndef cmd_status(args):\n    \"\"\"Show current health status of all services.\"\"\"\n    try:\n        checker = HealthChecker()\n    except RuntimeError as e:\n        print(f'ERROR: {e}', file=sys.stderr)\n        return 2\n    \n    storage = HealthStorage()\n    results = checker.check_all_services()\n    \n    # Header\n    print(f'{\"Service\":<25} {\"Status\":<12} {\"Response\":<10} {\"Details\"}')\n    print('-' * 70)\n    \n    unhealthy_count = 0\n    for result in results:\n        status_str = result.status.value\n        if result.status == HealthStatus.HEALTHY:\n            status_display = f'\\033[32m{status_str}\\033[0m'  # green\n        elif result.status == HealthStatus.UNHEALTHY:\n            status_display = f'\\033[31m{status_str}\\033[0m'  # red\n            unhealthy_count += 1\n        else:  # MISSING\n            status_display = f'\\033[33m{status_str}\\033[0m'  # yellow\n            unhealthy_count += 1\n        \n        response = f'{result.response_time_ms}ms'\n        details = ''\n        if result.details:\n            if 'error' in result.details:\n                details = result.details['error'][:30]\n            elif 'docker_health' in result.details:\n                details = f\"docker: {result.details['docker_health']}\"\n        \n        # Use raw status for width calculation\n        print(f'{result.service_name:<25} {status_display:<21} {response:<10} {details}')\n    \n    print()\n    if unhealthy_count == 0:\n        print('All services healthy')\n    else:\n        print(f'{unhealthy_count} service(s) unhealthy')\n    \n    return 0 if unhealthy_count == 0 else 1\n\n\ndef cmd_history(args):\n    \"\"\"Show recent health check history.\"\"\"\n    storage = HealthStorage()\n    history = storage.get_history(hours=args.hours, service_name=args.service)\n    \n    if not history:\n        print(f'No health checks recorded in the last {args.hours} hours')\n        return 0\n    \n    print(f'{\"Time\":<20} {\"Service\":<25} {\"Status\":<12} {\"Response\"}')\n    print('-' * 65)\n    \n    for record in history[:args.limit]:\n        time_str = record['checked_at'][:19]  # trim microseconds\n        print(f'{time_str:<20} {record[\"service_name\"]:<25} '\n              f'{record[\"status\"]:<12} {record[\"response_time_ms\"]}ms')\n    \n    total = len(history)\n    if total > args.limit:\n        print(f'\\n... and {total - args.limit} more records')\n    \n    return 0\n\n\ndef cmd_uptime(args):\n    \"\"\"Show uptime percentages for services.\"\"\"\n    storage = HealthStorage()\n    stats = storage.get_uptime_stats(days=args.days)\n    \n    if not stats:\n        print(f'No health checks recorded in the last {args.days} days')\n        return 0\n    \n    print(f'Uptime over the last {args.days} day(s):')\n    print(f'{\"Service\":<25} {\"Uptime\":<10}')\n    print('-' * 35)\n    \n    for service_name in SERVICE_CONTAINERS.keys():\n        uptime = stats.get(service_name, 0.0)\n        if uptime >= 99.0:\n            color = '\\033[32m'  # green\n        elif uptime >= 95.0:\n            color = '\\033[33m'  # yellow\n        else:\n            color = '\\033[31m'  # red\n        \n        print(f'{service_name:<25} {color}{uptime:>6.2f}%\\033[0m')\n    \n    return 0\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='Query Postiz stack health status and history'\n    )\n    subparsers = parser.add_subparsers(dest='command', required=True)\n    \n    # status command\n    status_parser = subparsers.add_parser(\n        'status', help='Show current health status of all services'\n    )\n    status_parser.set_defaults(func=cmd_status)\n    \n    # history command\n    history_parser = subparsers.add_parser(\n        'history', help='Show recent health check history'\n    )\n    history_parser.add_argument(\n        '--hours', type=int, default=24,\n        help='Hours of history to show (default: 24)'\n    )\n    history_parser.add_argument(\n        '--service', type=str, default=None,\n        help='Filter by service name'\n    )\n    history_parser.add_argument(\n        '--limit', type=int, default=50,\n        help='Maximum records to show (default: 50)'\n    )\n    history_parser.set_defaults(func=cmd_history)\n    \n    # uptime command\n    uptime_parser = subparsers.add_parser(\n        'uptime', help='Show uptime percentages'\n    )\n    uptime_parser.add_argument(\n        '--days', type=int, default=7,\n        help='Days to calculate uptime over (default: 7)'\n    )\n    uptime_parser.set_defaults(func=cmd_uptime)\n    \n    args = parser.parse_args()\n    sys.exit(args.func(args))\n\n\nif __name__ == '__main__':\n    main()\n```",
        "testStrategy": "1. Unit tests:\n   - Test cmd_status output formatting\n   - Test cmd_history with various filters\n   - Test cmd_uptime calculation display\n2. Integration tests:\n   - Run CLI with --help, verify output\n   - Run status with mocked checker\n   - Run history/uptime with prepopulated database",
        "priority": "high",
        "dependencies": [
          "2",
          "5"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed - implementation is fully specified in task details"
      },
      {
        "id": "7",
        "title": "Add Makefile targets for health monitoring",
        "description": "Extend the existing Makefile with health, health-history, and health-uptime targets for convenient access to health monitoring commands.",
        "details": "Update `Makefile` to add health monitoring targets:\n\n```makefile\n# Add to existing Makefile\n\n.PHONY: health health-history health-uptime health-monitor\n\n# Run a single health check\nhealth:\n\tpython scripts/health_cli.py status\n\n# Show health check history (last 24 hours)\nhealth-history:\n\tpython scripts/health_cli.py history\n\n# Show uptime percentages (last 7 days)\nhealth-uptime:\n\tpython scripts/health_cli.py uptime\n\n# Start continuous health monitoring\nhealth-monitor:\n\tpython scripts/health_monitor.py --verbose\n```\n\nThe resulting Makefile should look like:\n```makefile\n.PHONY: up down logs restart status clean health health-history health-uptime health-monitor\n\nup:\n\tdocker compose up -d\n\ndown:\n\tdocker compose down\n\nlogs:\n\tdocker compose logs -f postiz\n\nrestart: down up\n\nstatus:\n\tdocker compose ps\n\nclean:\n\t@echo \"WARNING: This removes all volumes (database data, uploads, etc.)\"\n\t@read -p \"Are you sure? [y/N] \" confirm && [ \"$$confirm\" = \"y\" ] && docker compose down -v || echo \"Aborted.\"\n\n# Health monitoring\nhealth:\n\tpython scripts/health_cli.py status\n\nhealth-history:\n\tpython scripts/health_cli.py history\n\nhealth-uptime:\n\tpython scripts/health_cli.py uptime\n\nhealth-monitor:\n\tpython scripts/health_monitor.py --verbose\n```",
        "testStrategy": "1. Run `make health` and verify it calls the correct script\n2. Run `make health-history` and verify output\n3. Run `make health-uptime` and verify output\n4. Run `make health-monitor` (interrupt with Ctrl+C) and verify it starts",
        "priority": "medium",
        "dependencies": [
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 1,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed - trivial configuration change"
      },
      {
        "id": "8",
        "title": "Write comprehensive test suite",
        "description": "Create pytest-based test suite covering all health monitoring components with unit tests, integration tests, and mocked Docker/webhook scenarios.",
        "details": "Create `tests/` directory structure:\n\n```\ntests/\n├── __init__.py\n├── conftest.py          # Shared fixtures\n├── test_storage.py      # Storage layer tests\n├── test_checker.py      # Health checker tests  \n├── test_notifier.py     # Notification tests\n├── test_monitor.py      # Main script tests\n└── test_cli.py          # CLI tests\n```\n\nCreate `tests/conftest.py`:\n```python\nimport pytest\nimport sys\nfrom pathlib import Path\n\n# Add scripts to path\nscripts_dir = Path(__file__).parent.parent / 'scripts'\nsys.path.insert(0, str(scripts_dir))\n\n@pytest.fixture\ndef temp_db(tmp_path):\n    \"\"\"Create a temporary SQLite database.\"\"\"\n    db_path = tmp_path / 'test_health.sqlite'\n    from health_storage import HealthStorage\n    return HealthStorage(db_path)\n\n@pytest.fixture\ndef mock_docker_client(mocker):\n    \"\"\"Create a mocked Docker client.\"\"\"\n    mock_client = mocker.MagicMock()\n    mocker.patch('docker.from_env', return_value=mock_client)\n    return mock_client\n```\n\nCreate `tests/test_storage.py`:\n```python\nimport pytest\nfrom health_storage import HealthStorage\n\nclass TestHealthStorage:\n    def test_schema_creation_idempotent(self, temp_db):\n        # Re-initialize shouldn't fail\n        temp_db._init_schema()\n        assert True\n    \n    def test_record_and_retrieve_check(self, temp_db):\n        temp_db.record_check('postiz', 'healthy', 50, {'docker_health': 'healthy'})\n        status = temp_db.get_last_status('postiz')\n        assert status == 'healthy'\n    \n    def test_get_last_status_unknown_service(self, temp_db):\n        status = temp_db.get_last_status('nonexistent')\n        assert status is None\n    \n    def test_state_transition_recording(self, temp_db):\n        tid = temp_db.record_transition('postiz', 'healthy', 'unhealthy')\n        assert tid > 0\n        temp_db.mark_webhook_sent(tid)\n    \n    def test_history_filtering(self, temp_db):\n        temp_db.record_check('postiz', 'healthy', 50)\n        temp_db.record_check('redis', 'unhealthy', 100)\n        \n        all_history = temp_db.get_history(hours=1)\n        assert len(all_history) == 2\n        \n        postiz_history = temp_db.get_history(hours=1, service_name='postiz')\n        assert len(postiz_history) == 1\n    \n    def test_uptime_calculation(self, temp_db):\n        # 3 healthy, 1 unhealthy = 75% uptime\n        for _ in range(3):\n            temp_db.record_check('postiz', 'healthy', 50)\n        temp_db.record_check('postiz', 'unhealthy', 50)\n        \n        stats = temp_db.get_uptime_stats(days=1)\n        assert abs(stats['postiz'] - 75.0) < 0.01\n```\n\nCreate `tests/test_checker.py`:\n```python\nimport pytest\nfrom unittest.mock import MagicMock\nfrom health_checker import HealthChecker, HealthStatus, HealthResult\n\nclass TestHealthChecker:\n    def test_container_not_found_returns_missing(self, mock_docker_client):\n        import docker.errors\n        mock_docker_client.containers.get.side_effect = docker.errors.NotFound('not found')\n        \n        checker = HealthChecker()\n        result = checker.check_service('postiz', 'postiz')\n        \n        assert result.status == HealthStatus.MISSING\n        assert 'not found' in result.details['error'].lower()\n    \n    def test_container_not_running_returns_unhealthy(self, mock_docker_client):\n        mock_container = MagicMock()\n        mock_container.status = 'exited'\n        mock_container.attrs = {}\n        mock_docker_client.containers.get.return_value = mock_container\n        \n        checker = HealthChecker()\n        result = checker.check_service('postiz', 'postiz')\n        \n        assert result.status == HealthStatus.UNHEALTHY\n    \n    def test_healthy_container_returns_healthy(self, mock_docker_client):\n        mock_container = MagicMock()\n        mock_container.status = 'running'\n        mock_container.attrs = {\n            'State': {'Health': {'Status': 'healthy', 'Log': []}}\n        }\n        mock_docker_client.containers.get.return_value = mock_container\n        \n        checker = HealthChecker()\n        result = checker.check_service('postiz', 'postiz')\n        \n        assert result.status == HealthStatus.HEALTHY\n```\n\nCreate `tests/test_notifier.py`:\n```python\nimport pytest\nfrom unittest.mock import MagicMock, patch\nfrom health_notifier import HealthNotifier\nfrom health_checker import HealthResult, HealthStatus\n\nclass TestHealthNotifier:\n    def test_no_transition_on_first_check(self, temp_db):\n        notifier = HealthNotifier(temp_db, webhook_url='')\n        result = HealthResult('postiz', HealthStatus.HEALTHY, 50)\n        \n        transition_id = notifier.process_result(result)\n        assert transition_id is None\n    \n    def test_no_transition_when_status_unchanged(self, temp_db):\n        notifier = HealthNotifier(temp_db, webhook_url='')\n        \n        # First check\n        result1 = HealthResult('postiz', HealthStatus.HEALTHY, 50)\n        notifier.process_result(result1)\n        \n        # Second check, same status\n        result2 = HealthResult('postiz', HealthStatus.HEALTHY, 45)\n        transition_id = notifier.process_result(result2)\n        \n        assert transition_id is None\n    \n    def test_transition_detected_on_status_change(self, temp_db):\n        notifier = HealthNotifier(temp_db, webhook_url='')\n        \n        # First check: healthy\n        result1 = HealthResult('postiz', HealthStatus.HEALTHY, 50)\n        notifier.process_result(result1)\n        \n        # Second check: unhealthy\n        result2 = HealthResult('postiz', HealthStatus.UNHEALTHY, 5000, \n                               {'error': 'Connection refused'})\n        transition_id = notifier.process_result(result2)\n        \n        assert transition_id is not None\n        assert transition_id > 0\n    \n    @patch('health_notifier.httpx.Client')\n    def test_webhook_payload_structure(self, mock_httpx, temp_db):\n        mock_client = MagicMock()\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_client.__enter__.return_value.post.return_value = mock_response\n        mock_httpx.return_value = mock_client\n        \n        notifier = HealthNotifier(temp_db, webhook_url='http://test.local/webhook')\n        success = notifier.send_webhook('postiz', 'healthy', 'unhealthy', \n                                        {'error': 'test'})\n        \n        assert success\n        call_args = mock_client.__enter__.return_value.post.call_args\n        payload = call_args[1]['json']\n        \n        assert payload['event'] == 'service_status_change'\n        assert payload['service'] == 'postiz'\n        assert payload['from_status'] == 'healthy'\n        assert payload['to_status'] == 'unhealthy'\n        assert 'timestamp' in payload\n        assert payload['stack'] == 'postiz-social-automation'\n```\n\nAdd pytest config to `pyproject.toml`:\n```toml\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\npython_functions = [\"test_*\"]\nmarkers = [\n    \"integration: marks tests as integration tests (may require Docker)\",\n]\n```",
        "testStrategy": "1. Run `pytest tests/` and verify all tests pass\n2. Run `pytest tests/ --cov=scripts` to verify coverage\n3. Run individual test files to verify isolation\n4. Verify mocking works correctly for Docker and HTTP calls",
        "priority": "medium",
        "dependencies": [
          "2",
          "3",
          "4",
          "5",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up test infrastructure (conftest.py, pytest config)",
            "description": "Create the tests/ directory structure with __init__.py, conftest.py containing shared fixtures, and add pytest configuration to pyproject.toml.",
            "dependencies": [],
            "details": "Create tests/ directory with __init__.py. Implement conftest.py with shared fixtures: temp_db fixture using tmp_path for SQLite, mock_docker_client fixture using mocker to patch docker.from_env(), and any other common fixtures needed across test modules. Add [tool.pytest.ini_options] section to pyproject.toml with testpaths, python_files, python_functions patterns, and markers for integration tests. Ensure scripts directory is added to sys.path in conftest.py for local imports.",
            "status": "pending",
            "testStrategy": "Run `pytest --collect-only` to verify pytest can discover the test structure. Verify fixtures are accessible by creating a minimal test that uses temp_db and mock_docker_client fixtures.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement storage layer tests (test_storage.py)",
            "description": "Create comprehensive unit tests for the HealthStorage class covering schema creation, CRUD operations, state transitions, history filtering, and uptime calculations.",
            "dependencies": [
              1
            ],
            "details": "Create tests/test_storage.py with TestHealthStorage class. Test cases: test_schema_creation_idempotent (re-init shouldn't fail), test_record_and_retrieve_check (record then get_last_status), test_get_last_status_unknown_service (returns None), test_state_transition_recording (record_transition and mark_webhook_sent), test_history_filtering (filter by hours and service_name), test_uptime_calculation (verify percentage math with known healthy/unhealthy ratio). Use temp_db fixture from conftest.py for all tests.",
            "status": "pending",
            "testStrategy": "Run `pytest tests/test_storage.py -v` and verify all 6+ test cases pass. Verify tests are isolated by running them in random order with `pytest tests/test_storage.py -v --random-order` (if plugin available).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement checker and notifier tests (test_checker.py, test_notifier.py)",
            "description": "Create unit tests for HealthChecker and HealthNotifier classes with mocked Docker client and HTTP client for webhook testing.",
            "dependencies": [
              1
            ],
            "details": "Create tests/test_checker.py with TestHealthChecker class. Test cases: test_container_not_found_returns_missing (mock NotFound exception), test_container_not_running_returns_unhealthy (mock exited container), test_healthy_container_returns_healthy (mock running container with healthy status). Create tests/test_notifier.py with TestHealthNotifier class. Test cases: test_no_transition_on_first_check, test_no_transition_when_status_unchanged, test_transition_detected_on_status_change, test_webhook_payload_structure (patch httpx.Client and verify payload contains event, service, from_status, to_status, timestamp, stack fields).",
            "status": "pending",
            "testStrategy": "Run `pytest tests/test_checker.py tests/test_notifier.py -v` and verify all tests pass. Verify mocks are working correctly by checking that no actual Docker or HTTP calls are made during tests.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement integration tests for monitor and CLI (test_monitor.py, test_cli.py)",
            "description": "Create integration tests for the main health_monitor.py script and CLI interface, testing run_once functionality, exit codes, and command-line argument handling.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create tests/test_monitor.py with TestHealthMonitor class. Test cases: test_run_once_all_healthy (mock checker returning all healthy, verify exit code 0), test_run_once_some_unhealthy (mock checker returning mixed results, verify exit code 1), test_docker_daemon_error_handling (mock DockerException, verify graceful handling). Create tests/test_cli.py with TestCLI class. Test cases: test_once_flag_runs_single_check, test_status_command_output_format, test_history_command_output, test_invalid_arguments_exit_code. Mark integration tests that require Docker with @pytest.mark.integration decorator for selective test running.",
            "status": "pending",
            "testStrategy": "Run `pytest tests/test_monitor.py tests/test_cli.py -v` for unit tests. Run `pytest -m integration` separately when Docker is available. Verify exit codes match expected behavior for healthy/unhealthy states.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down test suite creation into: 1) Test infrastructure setup (conftest.py, pytest config in pyproject.toml), 2) Storage layer tests (test_storage.py), 3) Checker and notifier tests (test_checker.py, test_notifier.py), 4) Integration tests for monitor and CLI (test_monitor.py, test_cli.py)"
      },
      {
        "id": "9",
        "title": "Update documentation and .env.example",
        "description": "Update project documentation with health monitoring usage instructions and add configuration variables to .env.example.",
        "details": "1. Update `.env.example` by appending:\n```\n# Health Monitoring (optional)\nHEALTH_CHECK_INTERVAL=60          # seconds between checks\nHEALTH_WEBHOOK_URL=               # n8n webhook URL for alerts\nHEALTH_DB_PATH=var/health.sqlite  # SQLite database location\n```\n\n2. Update `CLAUDE.md` to add health monitoring commands:\n\nAdd to the \"Development Commands\" section:\n```markdown\n## Health Monitoring\n\n```bash\n# Check current service health\nmake health\n\n# View health history (last 24 hours)\nmake health-history\n\n# View uptime percentages (last 7 days)\nmake health-uptime\n\n# Start continuous monitoring\nmake health-monitor\n\n# Or via Python directly\npython scripts/health_cli.py status\npython scripts/health_cli.py history --hours 48\npython scripts/health_cli.py uptime --days 30\npython scripts/health_monitor.py --once -v\n```\n```\n\n3. Add to \"Current Focus\" section:\n```markdown\n- [x] Health monitoring system with SQLite persistence\n```\n\n4. Update \"Structure\" section to include:\n```\nscripts/\n├── health_monitor.py     # Continuous health monitoring\n├── health_cli.py         # CLI for status/history/uptime\n├── health_checker.py     # Docker health checks\n├── health_storage.py     # SQLite persistence\n└── health_notifier.py    # Webhook notifications\nvar/\n└── health.sqlite         # Health check database\n```",
        "testStrategy": "1. Verify .env.example contains all required variables\n2. Verify CLAUDE.md renders correctly in markdown viewer\n3. Test that documented commands work as described",
        "priority": "low",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "No expansion needed - straightforward documentation updates"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-21T01:10:25.163Z",
      "taskCount": 9,
      "completedCount": 2,
      "tags": [
        "health-monitoring"
      ]
    }
  }
}